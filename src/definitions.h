#ifndef DEFINITIONS_H
#define DEFINITIONS_H

/////////////////////////////////////////////////////////////////////////////////////////////////////////
///     definitions.h - вспомогательные функции и макроопределения
///
///                     ИНТЕРПРЕТАТОР 1.0
/////////////////////////////////////////////////////////////////////////////////////////////////////////

// ПОДКЛЮЧАЕМЫЕ ФАЙЛЫ:

#include <ctype.h>           // функции обработки символов
#include <time.h>             // системный таймер необходим для генерации случайных чисел функцией rand
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>

//=============================================================================
// выбрать ОС:

#define LINUX
//#define WINDOWS
//=============================================================================

#ifdef LINUX
#define SOURCE "gedit \"Код.txt\""
#define RESULT "gedit \"Результат.txt\""
#else
char * get_windows1251(const char * const utf8);
static char *SOURCE = get_windows1251("notepad \"Код.txt\"");
static char *RESULT = get_windows1251("notepad \"Результат.txt\"");
#endif

//=============================================================================

struct complex;

//=============================================================================
// ОПРЕДЕЛЕНИЕ ТИПОВ ДАННЫХ:

typedef int THIS_IS; // используется в структуре token двусвязного списка лексем
//=============================================================================
// МАКРООПРЕДЕЛЕНИЯ:

//  Нижеперечисленные константы пределяют, чем является лексема в списке - функцией,
//  числом или оператором.

// тип данных - число
#define NUMBER          1
// оператор +
#define PLUS            2
// знак или оператор -
#define MINUS           3
// оператор умножения *
#define MULTIPLICATION  4
// оператор деления /
#define DIVISION        5
// оператор степени ^, например 2^3 = 8
#define DEGREE          6
// открывающаяся скобка (
#define BRECKET_OPEN    7
// закрывающаяся скобка )
#define BRECKET_CLOSE   8
// оператор факториал числа !, 3! = 6
#define FACTORIAL       9
// функция-экспонента (число Е в степени...) exp
#define EXP             10
// оператор остаток по модулю (если число вещественное, дробная часть отбрасывается)
#define MOD             11
// оператор частное по модулю (например, 15 div 4 = 3), если число вещественное,
// дробная часть отбрасывается
#define DIV             12
// функция натурального логарифма, ln (exp 6) = 6
#define LN              13
// функция синуса, sin 30 = 0.5
#define SIN             14
// функция косинуса cos
#define COS             15
// функция тангенса, tg 45 = 1
#define TG              16
// функция котангенса, ctg 45 = 1
#define CTG             17
// модуль числа, например |-2| = 2, имеет одинаковый приоритет со скобками
#define MODULE          18
// функция абсолютного значения, т.е. модуль числа, abs(2) = abs(-2) = 2
#define ABSVALUE        19
// функция арксинуса, asin(0.5) = 30
#define ASIN            20
// функция арккосинуса, acos(0.5) = 60
#define ACOS            21
// функция арктангенса, atg(1) = 45
#define ATAN            22
// функция арккотангенса, actg(1) = 45
#define ACTAN           23
// функция квадратного корня числа, sqrt(4) = 2
#define SQRT            24
// функция квадрата числа, sqr 4 = 16
#define SQR             25
// функция куба числа, cub 4 = 64
#define CUB             26
// функция кубического корня числа, cbrt 27 = 3
#define CBRT            27
// функция нахождения гипотенузы (a*a + b*b)^0.5, имеет два аргумента
#define HYPOT           28
// оператор запятая, разделяет параметры в функциях от нескольких аргументов,
// например hypot (3, 4) = 5
#define COMMA           29
// оператор, определяющий дробь, 1#2#3 + 1#3 = 2
#define FRACTION        30
// функция округления числа, round(2,4)  2
#define ROUND           31
// функция десятичного логарифма lg
#define LG              32
// функция логарифма по произвольному основанию (два аргумента), log(49, 7) = 2
#define LOG             33
// функция генерации случайного числа в некотром диапазоне (два аргумента),
// rand (2,3) = 2.128
#define RAND            34
// функция среднего значения двух чисел (два аргумента), mid(4, 7) = 5.5
#define MIDDLE          35
// функция нахождения максимального числа из двух (два аргумента), мах(2, 5) = 5
#define MAX2            36
// функция нахождения минимального числа из двух (два аргумента), min(2, 5) = 2
#define MIN2            37
// функция нахождения наибольшего общего делителя (два аргумента), nod(100, 75) = 25
#define NOD_DEL         38
// функция возведения в степень (два аргумента), pow (3, 2) = 9
#define POW             39
// оператор присваивания = , a = 2
#define EQUAL           40
// тип данных пользовательская переменная
#define VARIABLE        41
// функция аргумента комплексного числа, arg(i) = 90
#define ARG             42
// функция модуля комплексного числа, module(i) = 1
#define COMPLEX_MODULE  43
// функция нахождения комплексно-сопряженного, conj(1+i) = 1-i
#define CONJ            44
// функция гиперболического синуса, sh(0) = 0
#define SH_             45
// функция гиперболического косинуса, ch(0) = 1
#define CH              46
// функция гиперболического тангенса, th(0) = 0
#define TH              47
// функция гиперболического котангенса, cth(0) = 1.31304
#define CTH             48
// функция гиперболического арксинуса, ash(0) = 0
#define ASH             49
// функция гиперболического арккосинуса, ach(1) = 0
#define ACH             50
// функция гиперболического арктангенса, ath(0) = 0
#define ATH             51
// функция гиперболического арккотангенса, acth(0) = 1.5708i
#define ACTH            52
// функция секанса, sec(60) = 2
#define SEC             53
// функция косеканса, csec(30) = 2
#define CSEC            54
// функция перевода градусов в радианы, torad(180) = 3.14159
#define TORAD           55
// функция перевода радианов в градусы, todeg(3.14159) = 180
#define TODEG           56
// логический оператор отрицания (унарный), not 1 = false
#define NOT             57
// логический оператор И (бинарный), 1 and 0 = false
#define AND             58
// логический оператор ИЛИ (бинарный), 1 or 0 = true
#define OR              59
// логический оператор равно (бинарный), 2 == 2 = true
#define EGALE           60
// логический оператор не равно , 2 <> 2 = false
#define NE_EGALE        61
// логический оператор больше >
#define GREATER_THAN    62
// логический оператор меньше <
#define LESS_THAN       63
// логический оператор >=
#define GREATER_OR_EQUAL    64
// логический оператор  <=
#define LESS_OR_EQUAL       65
// логический тип данных
#define BOOL                66
// строковый тип данных
#define STRING              67
// функция вычисления определенного интеграла (4 аргумента), Integral("x+1", "x", 0,1) = 1.5,
#define INTEGRAL            68
// оператор точка, служит разделителем имени переменной и комплексной или действительной
// части значения переменной (как доступ к членам структуры в языке C/С++)
#define POINT               69
// идентификатор действительной части значения переменной, var.re
#define MEMBER_STRUCT_RE    70
// идентификатор комплексной части значения переменной, var.im
#define MEMBER_STRUCT_IM    71
// "перегруженая" функция, и в зависимости чем является входной параметр, записывает в
// выходной файл строку, число или логическое значение. Возвращает количество записаных
// байт. Если файл недоступен, возвращает 0. write("Hello"), write(2+2), write (a==b)
#define WRITE               72
// та же функция, только записывает еще символ новой строки
#define WRITELN             73
// оператор if
#define IF                  74
// оператор while
#define WHILE               75
// оператор for
#define FOR                 76
// оператор do
#define DO                  77
// функция func создания пользовательской функции
#define FUNCTION            78
// функция run выполняет пользовательскую функцию, имя которой передается в качестве
// строкового параметра. Возвращает результат функции.
#define RUN                 79
// функция return завершает функцию, возвращая значение. Если утверждение встретилось вне
// всякой функции, то метод interpret возвращает её параметр:
// a=10, return(a), b=5 - b не инициализируется.
#define RETURN              80
// функция getre возвращает действительную часть числа, getre(3+2i) = 3
#define GETRE               81
// функция getim возвращает комплексную часть числа, getim(3+2i) = 2i
#define GETIM               82
// оператор break
#define BREAK               83
// оператор continue
#define CONTINUE            84
// идентификатор cout
#define COUT1               85
// оператор << используется вместе с cout
#define COUT2               86
// оператор else
#define ELSE                87
// функция new - объявление массивов
#define NEW                 88
// идентификатор - элемент массива
#define ELEMENT_ARRAY       89
// открывающаяся квадратная скобка
#define SQUARE_BRECKET_OPEN 90
// закрывающаяся квадратная скобка
#define SQUARE_BRECKET_CLOSE    91
// команда exit - завершение приложения
#define EXIT                92
// функция exact - установка точности отображения чисел
#define EXACT               93

//------------------------------------------------------------------------------
// Нижеперечисленные константы определяют основные вычислительные параметры
// интерпретатора.

// Если счетчик итераций циклов раэбиения строки на лексемы или вычисления выражения
// достигает данного значения, функция вычисления завершается, флаг error устанавливается
// в true и выводится сообщение о синтаксической ошибке в выражении
#define LIMITE_ERROR 1000

// максимальная длина пользовательской переменной
#define SIZE_UNIQUE_WORD_AND_VARIABLES 200

// максимальное количество переменных
#define QUANTITY_VARIABLES 1000

// наибольшая длина арифметического выражения
#define MAX_EXPRESSION 32000

// параметры, определяющие размер массива строк:
// максимальное количество строк
#define QUANTITY_STRINGS 5000

// максимальная длина строки
#define MAX_STRING MAX_EXPRESSION

// максимальное время в секундах, отводимое на вычисление одного интеграла
#define TIME_CALCULATION_INTEGRALE 15

// наибольшая длина имени пользовательской функции
#define MAX_NAME_USER_FUNCTION  200

// максимальное количество пользовательских функций
#define MAX_QUANTITY_USER_FUNCTION 1000

// максимальное количество пользовательских массивов
#define MAX_QUANTITY_USER_ARRAY 1000

// максимальное количество элементов в пользовательском массиве
#define MAX_SIZE_USER_ARRAY 32000

// максимальное количество знаков после запятой, с которым отображается числовой результат
#define MAX_EXACT   20


//================ МАКРООПРЕДЕЛЕНИЯ ========================================================================

// наибольшее из двух чисел
#define MAX(a,b) ( ((a) > (b)) ? (a) : (b) )

// наименьшее из двух чисел
#define MIN(a,b) (((a) > (b)) ? (b) : (a))

// модуль числа
#define ABS(x) ((x) >= 0.) ? (x) : -1.*(x)


// Физические константы:
#define k_c     299.792458E6
#define k_g     9.80665
#define k_G     66.725985E-12
#define k_Vm    22.4141E-3
#define k_Na    602.2136736E21
#define k_e     160.2177335E-21
#define k_me    910.9389754E-33
#define k_mp    1.67262311E-27
#define k_mn    1.67492861E-27
#define k_h     662.607554E-36
#define k_k     13.8065812E-24
#define k_R     8.3145107
#define k_m0    1.256637061E-6
#define k_e0    8.854187818E-12

// Математические константы:
//#define M_E_     2.71828182845904523536
#define M_PI    3.14159265358979323846



extern bool error, // равен true если в ходе вычисления строки обнаружена ошибка;

     Write, // равен true если вызывались ли в текущем выражении функции write или writeln;

     ThisComment,   // равен true если пустое выражение;

     return_func,   // равен true если в выражении выполнилась функция return.

     run_break,     // равен true если выполнилась команда break
     run_continue;

struct Variable // структура пользовательской переменной
{
    double ValueVar,    // вещественное значение переменной
           Im_ValueVar; // комплексное  значение переменной

    char   NameVar [SIZE_UNIQUE_WORD_AND_VARIABLES]; // имя переменной, регистр
    // учитывается, переменные в массиве не повторяются

};

struct UserArray // структура пользовательского массива
{
    char nameArray [MAX_NAME_USER_FUNCTION]; // имя массива
    int dim, // размерность массива = 1 или 2 (одномерный и двумерный)
        i, // число строк
        j; // число столбцов
    complex *elements; // указатель на блок элементов массива
};

struct Function // структура пользовательской функции
{
    char name [MAX_NAME_USER_FUNCTION], // имя функции
         *body; // тело функции

};

//================ ПРОТОТИПЫ ФУНКЦИЙ =======================================================================

// СТРОКОВЫЕ И СИМВОЛЬНЫЕ ФУНКЦИИ

#ifdef WINDOWS
// печатает на консоли русский символ с, возвращает результат функции putc
int     rputcstd   (int  c);
#endif

int convert_utf8_to_windows1251(const char* utf8, char* windows1251, size_t n); // перевод строки из кодировки UTF-8 в С1251
#ifdef LINUX
void convert_cp1251_to_utf8(char *out, const char *in);
char * get_utf8(const char * const cp1251); // // возвратить строку в кодировке utf8
#endif
char * get_windows1251(const char * const utf8); // возвратить строку в кодировке сp1251

char convCyrSymb (char c); // перевод кодировки кириллического символа
char * convCyrStr (char *s); // перевод кодировки кириллической строки


// выводит кириллическую строку на консоль с переводом курсора на следующую строку.
// Возвращает количество выведенных байт.
int     rputs  (const char * const s);

// то же, но курсор не переводит.
int    rprin  (const char * s);

// возвращает истину, если символ является буквой русского или английского алфавита
int isalpha_ (int c);

//-------------------------------------------------------------------------------
// МАТЕМАТИЧЕСКИЕ ФУНКЦИИ

// возвращает значение corner переведенное из градусов в радианы
double ToRadians (double corner);
// возвращает значение corner переведенное из радиан в градусы
double ToGrad    (double corner);

// возвращает "бесконечность" 1.#INF
double getInfinity ();

// возвращает факториал х
double fact      (double x);

// возвращает наибольший общий делитель х и y
int    NOD       (int x, int y);

// возвращает значение х округленное до ближайшего целого числа
double round     (double x);

//-------------------------------------------------------------------------------
// ФУНКЦИИ ОБЩЕГО НАЗНАЧЕНИЯ:

// Функция завершает работу приложения выводя на экран message - собщение об ошибке
void FatalError (const char *message);

// Функция записывает в файл out комплексное число xy с точностью exact знаков после
// запятой.
// Если exact равно 0, то программа устанавливает точность по своему усмотрению.
// Возвращает количество записаных байтов.
int WriteComplexNumberInFile (double x, double y, FILE *out, int exact = 0);


// возвращает истину, если файл с указанным именем в текущем каталоге существует
bool EXISTS (const char *name);

// Функция завершает работу приложения выводя на экран message - собщение об ошибке
void FatalError (char *message);

// выполняет fopen, поправляя кодировку имени файла
FILE* fopen_ (const char * name, const char * mode);

#endif // DEFINITIONS_H
