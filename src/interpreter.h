#ifndef INTERPRETER_H
#define INTERPRETER_H


/////////////////////////////////////////////////////////////////////////////////////////////////////////
///     interpreter.h - описание класса Interpreter разбора выражения,
///                        записанного в символьном массиве.
///
///                     ИНТЕРПРЕТАТОР 1.0
/////////////////////////////////////////////////////////////////////////////////////////////////////////


#include "definitions.h"
#include "complex.h"

extern int count_loop;     // счетчик вложенности циклов, используется для выполнения
// команд break и continue

//===============================================================================================================
// ГЛАВНЫЙ КЛАСС разбора выражения

class Interpreter
{
    // Структура двусвязанного списка лексем, создаемого при разбиении выражения на лексемы.
    // В каждом элементе списка хранится или число, или переменная, или оператор,
    // или функция и т.д. Что именно хранится (тип данных, название функции и т.д.),
    // определяет параметр ThisIs. Его значения указаны как define-константы в файле
    // definitions.h.
public: class token
    {
    public:
        double number,       // хранит действительную часть числа
               Im_number;    // хранит мнимую часть числа

        THIS_IS ThisIs;      // этот параметр определяет тип данных (число, оператор,
        // функция и т.д.) лексемы. В ходе вычисления выражения может переопределяться
        // по необходимости.

        int IndexVar,        // если лексема является переменной, этот индекс указывает
        // на элемент массива пользовательских переменных (массив структур хранящие имя
        // переменной и её значение).

            IndexString,     // если лексема является строкой, этот индекс указывает на
            // элемент массива строк strings

            IndexArray, // если лексема является элементом или именем массива, этот индекс
            // указывает на элемент массива пользовательских массивов ListArray
            j; // индекс  элемента массива
            // если встретилась конструкция a[0][2], где а - имя двумерного массива, то этот
            // элемент массива переводится в число, равное элемнту массива, параметр j
            // хранит индекс элемента чтобы в случае изменения значения элемента нужный
            // элемент можно было бы найти в списке лексем и обновить его значение.

        class token *next,  // указатель на следующий элемент списка
                     *prior; // указатель на предыдущий элемент

        token ()
        {
            IndexArray = -1; // индекс несуществующего массива. Нужно для кооректной работы метода RefreshValueElementArrayInList
        }

    }   *start, // указатель на начало списка;
        *end,   // указатель на конец списка;
        *temp;  // указатель для навигации по списку;

    int countString,     // счетчик строк в массиве strings

        countToken,      // определяет количество элементов в списке, если равно 1,
                         // вычисления заканчиваются и главный метод interpret возвращает
                         // значение выражения.

        iteration;       // вспомогательный счетчик итераций циклов разбиения строки на
        // лексемы и вычисления выражения. Если счетчик "зашкаливает", это свидетельствует
        // о синтаксической ошибке в выражении. Это простой способ обнаружения синтаксических ошибок в выражении.

    char *p;    // указатель на строку-выражение

//===============================================================================================================
// МЕТОДЫ РАБОТЫ С ДВУСВЯЗНЫМ СПИСКОМ:

    // добавляет в конец двусвязного списка новый элемент, если список пустой, то вставляется
    // как первый элемент.
    void AddInEndVersionShildt (class token *add, class token **end);

    // удаляет элемент из двусвязного списка, по необходимости переопределяя указатели на начало
    // и конец списка (если удаляется первый или последний элемент)
    void DelElementMyVersion    (class token *del,
                                                 class token **start,
                                                 class token **end);

    // удаление двух элементов справа от текущей лексемы (используется повсеместно)
    void Del_2_Elements ();

    // Функция освобождает память от списка, вызывается после завершения вычислений
    void DeleteAll (class token **start);

//===============================================================================================================
// МЕТОДЫ ВЫЧИСЛЕНИЯ ОПЕРАТОРОВ:

    // Лексема является числом или переменной или булевым значением ?
    bool IsNumberOrVariable (class token *ptr);

    void UnMinus (); // вычисление минуса числа

    void UnPlus (); // вычисление плюса числа

    void Not (); // логический оператор отрицания

    void Factorial (); // факториал числа

    // удалить лексемы вокруг лексемы ptr. Метод используется для удаления скобок вокруг числа.
    void DelBreckets (class token *ptr);

    // удалить скобки вокруг числа, например (2) = 2
    void DelBrecketsAroundNumber ();

    // аналогично удаляем модули вокруг числа, например |2| или |-2|
    void DelModulsAroundNumber ();

    bool IsFunction (class token *ptr); // лексема является функцией?

    bool IsSupremOperator (class token *ptr); // возвратить истину если лексема является оператором наивысшего приоритета

    bool IsMiddleOperator (class token *ptr); // возвратить истину если лексема является оператором среднего приоритета

    bool IsUnOperator (class token *ptr); // возвратить истину если лексема является унарным оператором, стоящим перед числом

    bool OperatorSupremePrioritet (class token *ptr);  // возвратить истину если лексема является оператором высшего приоритета или функцией

    bool LeftOperatorSupremePrioritet (); // возвратить истину если лексема слева является оператором высшего приоритета или функцией

    bool RightThirdOperatorSupremePrioritet (); // возвратить истину если третья справа лексема является оператором высшего приоритета или функцией

    bool RightFifthOperatorSupremePrioritet (); // для дробей, из трех чисел возвратить истину если пятая справа лексема является оператором высшего приоритета или функцией

    // возвратить истину если лексема слева является оператором высшего или
    // среднего приоритета
    bool LeftOperatorSupremePrioritet_2 ();

    // возвратить истину если третья справа лексема является оператором высшего
    // или среднего приоритета
    bool RightThirdOperatorSupremePrioritet_2 ();

    // возвратить истину если вторая справа лексема является оператором высшего приоритета
    bool RightSecondOperatorSupremePrioritet ();

    // возвратить истину если текущая лексема является вещественным числом или переменной
    bool IsRealNumberOrVar (class token *ptr);

    // возвратить истину если текущая лексема является комплексным числом или переменной
    bool IsImNumberOrVar (class token *ptr);

    // Лексема является идентификатором комплексной или действительной части
    // значения переменной ?
    bool IsMemberStruct (class token *ptr);

    // функция выполняет блок выражений в фигурных скобках.
    // Параметры: объект класса Interpreter и строка содержащая набор выражений,
    // разделенных как запятыми, так и точкой с запятой
    void run_block (Interpreter *ob, char *str);

    // метод выполняет конструкцию if, представленную в виде:
    // if (условие) {блок выражений 1} else {блок выражений 2});
    // или
    // if (условие) {блок выражений 1};
    // или
    // if (условие)
    //
    // Если условие истинно, выполняется блок выражений 1 , иначе блок выражений 2
    // (оба блока могут отсутствовать).
    // В условии также может находиться несколько выражений через запятую, в таком случае
    // истинность условия находится по последнему выражению, а могут отсутствовать - тогда
    // условие будет истинным.
    // Все блоки выражений могут быть пустыми.
    // Блоки выражений 1 и 2 могут в себя включать любые конструкции условий,
    // циклов и т.д.
    // Конструкцию if от других частей выражения можно отделять запятыми,
    // иначе всегда ставится ;
    // Как и любая функция, if возвращает числовое выражение:
    //      1 - условие выполнилось,
    //      0 - условие ложно
    void run_if ();

    // метод выполняет конструкцию while, представленную в виде:
    // while (условие) {тело цикла};
    // или
    // while (условие);
    //
    // Тело цикла выполняется пока истинно условие и может отсутствовать.
    // В условии также может находиться несколько выражений через запятую, в таком случае
    // истинность условия находится по последнему выражению.
    // Условие может быть пустыми, тогда цикл становится бесконечным, из которого
    // нет выхода (только завершение приложения). Тело цикла может в себя включать любые
    // конструкции условий, циклов и т.д.
    // Конструкцию while от других частей выражения можно отделять запятыми.
    // Как и любая функция, while возвращает числовое выражение: количество итераций цикла.
    void run_while ();

    // метод выполняет конструкцию for (аналогичную в С++):
    // for (действия перед циклом; условие; ) {тело цикла});
    // или
    // for (действия перед циклом; условие; тело цикла);
    //
    // Действия перед циклом разделенны запятыми, переменные обявленные в них видны и вне цикла.
    // Тело цикла (выражения, разделенные точкой с запятой) а затем действия после тела цикла
    // (выражения, разделенные запятой) выполняется пока истинно условие.
    // В условии также может находиться несколько выражений через запятую, в таком случае
    // истинность условия находится по последнему выражению.
    // Все наборы выражений могут быть пустыми, если пустое условие, то цикл становится
    // бесконечным, из которого нет выхода (только завершение приложения).
    // Тело цикла может в себя включать любые конструкции условий, циклов и т.д.
    // Конструкцию for от других частей выражения можно отделять запятыми.
    // Как и любая функция, for возвращает числовое выражение: количество итераций цикла.
    void run_for ();

    // метод выполняет конструкцию цикла с предусловием:
    // do {тело цикла} while (условие);
    //
    // Тело цикла (выражения, разделенные точкой с запятой) выполняется хотя бы один раз,
    // а затем пока истинно условие (цикл с предусловием - как в языке С++)
    void run_dowhile ();

    // Метод выполняет оператор cout, внешне напоминающий вывод в языке С++:
    // cout << аргумент;
    //
    // Идентификатор cout подобен потоковой переменной cout из С++ и не должен применяться в
    // арифметических выражениях.
    // Аргумент может быть числом, логическим значением или строкой.
    // Оператор << с помощью метода write записывает аргумент в поток и возвращает идентификатор
    // cout, сам по себе cout без оператора << и аргумента переводится в нулевое комплексное
    // число.
    void run_cout ();
//===============================================================================================================
// МЕТОДЫ ВЫЧИСЛЕНИЯ ФУНКЦИЙ ОТ ОДНОГО АРГУМЕНТА:

    // возвратить истину если лексема является функцией от одного аргумента
    bool IsFunction1Arg (class token *ptr);

    // вызывает целый ряд методов для определения и вычисления конкретной функции
    void Functions_Of1Arguments ();

    // выполняет функцию или функцию-оператор. Параметр ptr_arg указывает на аргумент функции,
    // n равно 1 если нужно выполнить функцию-оператор или 3 в случае обычной функции.
    void RunFunction1Arg (class token *ptr_arg, int n);

    void Function_Of1Argument ();

    // Метод выполняет функцию write - записывает в файл out - Результат.тхт данные,
    // хранящиеся в ptr_arg. Возвращает количество записаных байт.
    int write (FILE *out, class token *ptr_arg);

    // та же функция, только дозаписывает символ новой строки
    int writeln (FILE *out, class token *ptr_arg);


// методы вычисления функций-операторов:

    // вызывает целый ряд методов для определения и вычисления конкретной функции-оператора
    void Functions_Operators_Of1Arguments ();

    // вызывает, в зависимости от типа лексемы, одну из функций от одного аргумента
    void Function_OperatorOf1Argument ();

//===============================================================================================================
// МЕТОДЫ ВЫЧИСЛЕНИЯ ФУНКЦИЙ ОТ ДВУХ АРГУМЕНТОВ:

    // возвратить истину если лексема является функцией от двух аргументов
    bool IsFunction2Arg (class token *ptr);

    // Лексема является функцией от двух аргументов?
    bool IsFunctionOf2Arguments ();

    // вызывает целый ряд методов для определения и вычисления конкретной функции.
    void Functions_Of2Arguments ();

    void hypot ();
    void log_ ();
    void rand_ ();
    void middle ();
    void max_ ();
    void min_ ();
    void nod ();
    void pow_ ();

//===============================================================================================================
// МЕТОДЫ ВЫЧИСЛЕНИЯ ИНТЕГРАЛА:

    // Метод возвращает истину если текущая лексема является функцией вычисления интеграла
    bool IsIntegral ();

    // Вычисление определенного интеграла методом Симпсона.
    // integral ("интегрируемая_функция", подинтегральная_переменная, верхний_предел, нижний_предел);
    //
    // Первый аргумент - строка - содержит интегрируемую функцию - т.е. отдельное
    // арифметическое выражение, поэтому для него создается отдельный объект Integral класса
    // Interpreter, в него передаются массивы пользовательских функций, переменных и массивов
    // и вызывается метод interpret. Интегрировать можно только по переменной, имя которой
    // указано во втором параметре функции, для чего для Integral создается эта переменная.
    // В ходе работы метода Integral. В interpret могут еще вычисляться интегралы, создаваться
    // пользовательские функции, переменные и массивы, область их видимости - объект Integral,
    // но могут измениться значения переменных текущего объекта. Функции не переопределяются,
    // массивы также могут изменить содержание.
    void integral ();
//===============================================================================================================
// МЕТОДЫ РАБОТЫ С ПОЛЬЗОВАТЕЛЬСКИМИ МАССИВАМИ:
public:
    int countArray,     // текущее число пользовательских массивов в ListArray
        OLDcountArray;  // прежнее число массивов до разбора выражения.
        // Если в выражении будет найдена ошибка, все новые созданные массивы
        // будут удалены из ListArray, останется OLDcountArray массивов.
        // ListArray - глобальная переменная.
private:

    // Метод возвращает истину если в  находится пользовательский массив с
    // именем name, в глобальную переменную count запишется индекс существующего массива.
    // Метод применяется при создании новых пользовательских массивов, имена функций,
    // массивов и переменных не должны совпадать.
    bool ExistsArray (char *name);

    // Метод выполняет команду new для создания пользовательского массива, её формат:
    // new (имя_массива, число_элементов) - для одномерного массива
    // или
    // new (имя_массива, число_строк, число_элементов_в_строке) - для двумерного массива.
    //
    // Все массивы одного типа и хранят комплексные числа.
    // Имя массива может быть в кавычках или без кавычек. В памяти двумерные массивы
    // располагаются как одномерные. Если массив уже создан, то память под него выделенная
    // освобождается и выделяется новый блок памяти, данные при этом сохраняются (например,
    // если массив состоял из 5 элементов и затем переопределился и стал состоять из 10
    // элементов, то первые 5 элементов сохраняют прежние значения). Допустимо одномерные
    // массивы переоперелять в двумерные и наоборот.
    // число_строк и число_элементов_в_строке должны быть от 1 до MAX_SIZE_USER_ARRAY.
    // Если число элементов указано как дробное, то дробная часть отбрасывается.
    // Метод возвращает в список лексем число элементов созданного массива.
    void run_new ();

    // Метод переводит элемент одномерного массива в число:
    // имя_массива [индекс] -> число
    // имя_массива [индекс].re -> getre (число)
    // Индексация массива начинается с нуля.
    void element_array_1D_to_number ();

    // Метод переводит элемент двумерного массива в число:
    // имя_массива [индекс_строки][индекс_столбца] -> число
    // имя_массива [индекс_строки][индекс_столбца].re -> getre (число)
    void element_array_2D_to_number ();

    // Инициализация элемента одномерного массива:
    // a[index] = число
    // a[index].re = число
    // В список лексем возвращается число
    void initialization_element_array_1D ();

    // Инициализация элемента двумерного массива:
    // a[index1][index2] = число
    // a[index1][index2].re = число
    // В список лексем возвращается число
    void initialization_element_array_2D ();

    // Метод применяется в случае изменения элемента массива значения на Re_value и Im_value
    // (инициализация, присваивание нового значения). На элемент ссылается указатель temp.
    // Новое значение заносится в массив пользовательских массивов. Также все элементы
    // массива в выражении с соответствующим индексом меняют свои значения.
    void RefreshValueElementArrayInList (double Re_value, double Im_value);

    // метод удаляет из ListArray элементы в диапазоне от IndexBegin до IndexEnd
    // используется при разграничении области видимости объектов, например после выполнения
    // конструкции if необходимо удалить все массивы объявленные внутри неё.
    void DelArrays (int IndexBegin, int IndexEnd);

//===============================================================================================================
// МЕТОДЫ РАБОТЫ С ПОЛЬЗОВАТЕЛЬСКИМИ ПЕРЕМЕННЫМИ:

public:
    int countVariables,     // счетчик пользовательских переменных - общее их число
                            // в массиве ListVar

        OLDcountVariables;  // значение countVariables до вычисления выражения. Если в ходе
                            // вычисления выражения нашлись ошибки, то только что созданные
                            // переменные должны быть удалены с помощью утверждения
                            // countVariables = OLDcountVariables, после чего новые
                            // переменные будут недоступными
private:

    // Метод используется при создании новых переменных.
    // Возвращает истину, если строка str есть в списке имен функций/операторов/констант,
    // т.е. не может быть именем переменной.
    bool EqualNamesUnique (char *str);

    // Метод применяется в случае изменения переменной значения на Re_value и Im_value
    // (инициализация, присваивание нового значения). На переменную ссылается
    // указатель temp. Новое значение заносится в массив пользовательских
    // переменных. Также все переменные в выражении с данным именем меняют свои значения.
    void SaveValue (double Re_value, double Im_value);

    // Метод вызывается при разбиении выражения на лексемы, когда с помощью метода
    // EqualNamesUnique выяснилось что данная строка может быть именем переменной.
    void AddVariableInList (char *add);

    // Метод вызывается, когда необходимо создать новую переменую с именем add, занеся её
    // в массив пользовательских переменных. Метод используется при вычислении функции
    // интегрирования.
    void CreateVariable (char *add);

    // Меняет значение переменной add на указаные в параметрах. Метод используется при
    // вычислении функции интегрирования.
    void ChangeValueVariable (char *add, double Re_value, double Im_value);

    // Метод возвращает истину, если в массиве пользовательских переменных ListVar есть
    // переменная с именем name. Метод используется при объявлении новых пользовательских
    // функций, имена функций и переменных не должны совпадать.
    bool ExistsVariable (char *name);

    // Метод обновляет в списке лексем значения переменных и элементов массива.
    // Применяется после выполнения блока в фигурных скобках.
    void RefreshAllUserData ();

//===============================================================================================================
// МЕТОДЫ РАБОТЫ С ПОЛЬЗОВАТЕЛЬСКИМИ ФУНКЦИЯМИ:

public:
    int countFunctions,     // счетчик пользовательских функций - общее их число
                            // в массиве ListFunctions

        OLDcountFunctions;  // значение countFunctions до вычисления выражения. Если в ходе
                            // вычисления выражения нашлись ошибки, то только что созданные
                            // функции должны быть удалены с помощью утверждения
                            // countFunctions = OLDcountFunctions, после чего новые
                            // функции будут недоступными
private:

    // Метод удаляет из ListArray элементы в диапазоне от IndexBegin до IndexEnd,
    // используется при разграничении области видимости объектов
    void DelFunc (int IndexBegin, int IndexEnd);

    // Метод возвращает истину, если объявлена пользовательская функция с именем name.
    // Метод применяется при создании новых пользовательских переменных, имена функций и
    // переменных не должны совпадать.
    bool ExistsFunction (char *name);

    // Функция считывает из строки string допустимое имя пользовательской функции и записывает
    // его в name. Если подходящее имя не найдено, строку name оставляет нулевой.
    // Правила выбора имени для функции те же, что и для переменной.
    // Метод использует функция creatFunction.
    void GetNameFunction (char *string, char *name);

    // Метод создает новую пользовательскую функцию, выполняет команду func в виде функции с
    // двумя строковыми параметрами:
    // func ("имя_функции", {тело_функции});
    // Строки могут ограничиваться кавычками и фигурными скобками.
    // Правила выбора имени для функции те же, что и для переменной.
    // Пример: func ("f", {pi/2}) или func ("f", "pi/2"). Имя функции в кавычках можно не
    // писать: func (f, {pi/2}).
    // В теле функции может быть одно или несколько выражений, разделенных ЗАПЯТЫМИ, при этом
    // функция всегда должна возвращать числовое значение (если логическое, то переводится в
    // числовое). Если в теле одно выражение, то возвращается его результат, если несколько - то
    // последнего выражения. Также можно использовать условия, циклы (if, for,... - это на самом
    // деле обычные функции, возвращающие числовой ответ). При этом в функции в любом месте
    // можно использовать функцию return, например: func (f, {return (pi/2)}), действует она
    // аналогично оператору return в языке С++.
    // Внутри функций можно объявлять переменные, область их видимости - тело данной функции.
    // Функции и переменные текущего объекта "видны" в функции, при этом функция может изменить
    // значения "глобальных" переменных. Объявлять функции внутри функций нельзя.
    // Функции могут быть рекурсивными, т.е. вызывать сами себя. Однако создавать такие функции
    // нельзя, так как стек программы будет быстро исчерпан и приложение закроется, допускается
    // около 1000 рекурсивных вызовов.
    // В целом многие правила создания функций взяты из языка С++.
    // Пока функция не будет вызвана, тело её никак не проверяется на наличие ошибок и как и
    // любая строка может содержать всё что угодно.
    void creatFunction ();

    // Метод выполняет команду run, запуская пользовательскую функцию, имя которой хранится в
    // виде строки в лексеме ptr_arg (имя хранится в массиве strings, а лексема содержит
    // индекс строки в массиве). Команда run реализована в виде функции или функции-
    // оператора с одним строковым параметром - именем функции.
    // Метод возвращает комплексное число - результат функции. В слкчае ошибки в теле функции
    // возвращает 0.
    complex run_Function (class token *ptr_arg);

//===============================================================================================================
// ОТЛАДОЧНЫЕ МЕТОДЫ:

    // метод просматривает список лексем и выводит тип каждой лексемы
    void debug ();

//===============================================================================================================
// МЕТОДЫ ПОИСКА ОШИБОК:

    // функция поиска некоторых синтаксических ошибок в выражении
    void SearchErrors ();

//=================== ОСНОВНЫЕ МЕТОДЫ ================================================================
public:

        Interpreter ()
        {
            start = 0; // обнулить указатель на начало списка лексем
            // обнуление счетчиков пользовательских переменных, функций и массивов.
            countVariables = countFunctions = countArray = 0;
        }

        complex interpret (char *str); // главный метод разбора выражения.
        // Входной параметр: строка с выражением.
        // Возвращаемое значение: структура типа complex, содержащая результат вычислений.

private:

        // Функция просматривает строку, находит в ней лексемы и формирует двусвязный список лексем.
        // Создаются пользовательские переменные и производится поиск некоторых синтаксических
        // ошибок в списке.
        void FillingListLexeme (char *str);  // метод создания двусвязного списка лексем

        // функция вызывается в случае обнаружения ошибки в выражении, в результате чего
        // новые переменные,функции и массивы удаляются
        void Undo ()
        {
            countVariables = OLDcountVariables; // удалить новые переменные
            countFunctions = OLDcountFunctions; // удалить новые функции
            DeleteAll (&start); // удалить список лексем
            return_func = true;
        }

}; // class Interpreter

#endif // INTERPRETER_H

